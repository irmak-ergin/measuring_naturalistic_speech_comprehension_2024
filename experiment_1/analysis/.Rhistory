# ===========================
# Order per participant × base_story: which speed came first?
# ===========================
order_map <- df0 %>%
dplyr::filter(speech_rate %in% c("x1","x2.5")) %>%
dplyr::group_by(participant, base_story, speech_rate) %>%
dplyr::summarise(first_idx = min(index, na.rm = TRUE), .groups = "drop") %>%
tidyr::pivot_wider(names_from = speech_rate, values_from = first_idx) %>%
dplyr::mutate(
order_group = dplyr::case_when(
!is.na(`x2.5`) & !is.na(x1) & `x2.5` < x1 ~ "x2.5_first",
!is.na(`x2.5`) & !is.na(x1) & x1 < `x2.5` ~ "x1_first",
TRUE ~ NA_character_
)
) %>%
dplyr::select(participant, base_story, order_group)
# ===========================
# Keep only story-pairs with BOTH speeds
# ===========================
both_speeds <- df0 %>%
dplyr::filter(!is.na(mcq_bin)) %>%
dplyr::count(participant, base_story, speech_rate) %>%
tidyr::pivot_wider(names_from = speech_rate, values_from = n, values_fill = 0) %>%
dplyr::mutate(has_x1 = x1 > 0, has_x2.5 = `x2.5` > 0) %>%
dplyr::filter(has_x1 & has_x2.5) %>%
dplyr::distinct(participant, base_story)
# Attach order; require non-missing outcome & order
df.model <- df0 %>%
dplyr::inner_join(both_speeds, by = c("participant","base_story")) %>%
dplyr::left_join(order_map, by = c("participant","base_story")) %>%
dplyr::filter(!is.na(mcq_bin), !is.na(order_group)) %>%
dplyr::mutate(
speech_rate = forcats::fct_drop(speech_rate),
order_group = forcats::fct_drop(factor(order_group, levels = c("x1_first","x2.5_first")))
)
# ===========================
# Aggregate MCQ per segment (participant × base_story × speed × order)
# ===========================
agg_mcq <- df.model %>%
dplyr::group_by(participant, base_story, speech_rate, order_group, digit_span_grp, digit_noise_grp) %>%
dplyr::summarise(
n_correct = sum(mcq_bin, na.rm = TRUE),
n_total   = dplyr::n(),
.groups   = "drop"
) %>%
dplyr::filter(n_total > 0) %>%
dplyr::mutate(
speech_rate = forcats::fct_drop(speech_rate),
order_group = forcats::fct_drop(order_group)
)
# ===========================
# Diagnostics on levels present
# ===========================
cat("Levels in agg_mcq$speech_rate:\n"); print(levels(agg_mcq$speech_rate))
cat("Levels in agg_mcq$order_group:\n");  print(levels(agg_mcq$order_group))
cat("\nCounts by order_group:\n");         print(table(agg_mcq$order_group, useNA = "ifany"))
# ===========================
# Branch: fit Speed × Order if both orders exist; otherwise Speed-only
# ===========================
has_two_orders <- nlevels(agg_mcq$order_group) >= 2
if (has_two_orders) {
m_mcq_agg <- glmer(
cbind(n_correct, n_total - n_correct) ~ speech_rate * order_group +
(1 | digit_span_grp) + (1 | digit_noise_grp),
data = agg_mcq,
family = binomial
# control = glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 2e5))
)
cat("\n=== MCQ aggregated (GLMM) summary — Speed × Order ===\n")
print(summary(m_mcq_agg), corr = FALSE)
emm <- emmeans(m_mcq_agg, ~ speech_rate * order_group, type = "response")
cat("\n=== Estimated probabilities by Speech rate × Order ===\n")
print(emm)
cmp <- contrast(emm, method = "revpairwise", by = "order_group")  # x2.5 vs x1 within each order
cat("\n=== Pairwise contrast (x2.5 / x1) within each Order group ===\n")
print(cmp)
} else {
message("Only one order_group present after filtering; fitting speed-only model.")
m_speed <- glmer(
cbind(n_correct, n_total - n_correct) ~ speech_rate +
(1 | digit_span_grp) + (1 | digit_noise_grp),
data = agg_mcq,
family = binomial
# control = glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 2e5))
)
cat("\n=== MCQ aggregated (GLMM) summary — Speed only ===\n")
print(summary(m_speed), corr = FALSE)
emm_speed <- emmeans(m_speed, ~ speech_rate, type = "response")
cat("\n=== Estimated probabilities by Speech rate ===\n")
print(emm_speed)
cmp_speed <- contrast(emm_speed, method = "revpairwise")  # x2.5 vs x1
cat("\n=== Pairwise contrast (x2.5 / x1) ===\n")
print(cmp_speed)
}
# --- EMMs on probability scale (for plotting) ---
emm_mcq <- as.data.frame(emmeans(m_mcq_agg, ~ speech_rate * order_group, type = "response"))
# Columns are typically: speech_rate, order_group, prob, SE, asymp.LCL, asymp.UCL
# --- p-value for ORDER difference at x2.5 (for the star) ---
ord_within_rate_mcq <- as.data.frame(
contrast(emmeans(m_mcq_agg, ~ order_group | speech_rate, type = "response"),
method = "revpairwise")
)
p_x25_mcq <- ord_within_rate_mcq %>%
dplyr::filter(speech_rate == "x2.5") %>%
dplyr::pull(p.value)
sig_lab <- function(p) ifelse(p < .001, "***", ifelse(p < .01, "**", ifelse(p < .05, "*", "ns")))
star_lab_mcq <- sig_lab(p_x25_mcq)
# --- y-range spanned by the two order EMMs at x2.5 (for the bracket) ---
y_stats_mcq <- emm_mcq %>%
dplyr::filter(speech_rate == "x2.5") %>%
dplyr::summarise(ymin = min(prob), ymax = max(prob), .groups = "drop") %>%
dplyr::mutate(y_mid = 0.5 * (ymin + ymax))
# --- Plot aesthetics ---
pinks <- c("x1_first" = "#C2185B",   # deep pink
"x2.5_first" = "#F48FB1") # light pink
bracket_x <- 2.13   # a touch right of "x2.5" (discrete position 2)
tick_dx   <- 0.06   # horizontal tick length
ggplot(emm_mcq, aes(x = speech_rate, y = prob,
group = order_group, color = order_group)) +
geom_line(linewidth = 1) +
geom_point(size = 4, shape = 16) +
geom_linerange(aes(ymin = asymp.LCL, ymax = asymp.UCL), linewidth = 0.9) +
scale_x_discrete(limits = c("x1","x2.5"),
expand = expansion(mult = c(0.05, 0.25))) +
scale_color_manual(
values = pinks,
breaks = c("x1_first","x2.5_first"),
labels = c("x1 first","x2.5 first"),
name   = "Presentation Order"
) +
labs(x = "Speech Rate", y = "Predicted Multiple Choice QUestion Accuracy") +
# --- single bracket & star at x2.5 (to the right), with clipping off ---
geom_segment(data = y_stats_mcq,
aes(x = bracket_x, xend = bracket_x, y = ymin, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats_mcq,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymin, yend = ymin),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats_mcq,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymax, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_text(data = y_stats_mcq,
aes(x = bracket_x + 0.06, y = y_mid, label = star_lab_mcq),
inherit.aes = FALSE, size = 5) +
scale_y_continuous(breaks = c(0, 0.5, 1)) +
coord_cartesian(ylim = c(0, 1), clip = "off") +
theme_classic(base_size = 14) +
theme(
legend.position      = c(0.98, 0.30),
legend.justification = c(1, 1),
legend.title         = element_text(size = 12),
legend.background    = element_rect(fill = scales::alpha("white", 0.7), color = NA),
aspect.ratio         = 1,
axis.text.x          = element_text(size = 12),
axis.text.y          = element_text(size = 12)
) +
guides(color = guide_legend(override.aes = list(linetype = 0, shape = 16, size = 3)))
# ---------- Prep (no filter on slider) ----------
df0 <- df.data %>%
dplyr::group_by(participant) %>%
dplyr::mutate(index = if (!"index" %in% names(dplyr::cur_data())) dplyr::row_number() else index) %>%
dplyr::ungroup() %>%
dplyr::mutate(
base_story = stringr::str_remove(story_name, "_sped$"),
speech_rate = factor(ifelse(speech_rate == 1, "x1", "x2.5"), levels = c("x1","x2.5")),
# robust numeric parse (turn "", "NA", "NaN" into real NA)
trial_median_rescaled = {
x <- as.character(trial_median_rescaled)
x[x %in% c("", "NA", "NaN")] <- NA_character_
suppressWarnings(as.numeric(x))
},
digit_span_grp  = factor(digit_span_score),
digit_noise_grp = factor(digit_in_noise_score)
)
# ---------- Order per participant × story (from ALL rows) ----------
order_map <- df0 %>%
dplyr::filter(speech_rate %in% c("x1","x2.5")) %>%
dplyr::group_by(participant, base_story, speech_rate) %>%
dplyr::summarise(first_idx = min(index, na.rm = TRUE), .groups = "drop") %>%
tidyr::pivot_wider(names_from = speech_rate, values_from = first_idx) %>%
dplyr::mutate(
order_group = dplyr::case_when(
!is.na(`x2.5`) & !is.na(x1) & `x2.5` < x1 ~ "x2.5_first",
!is.na(`x2.5`) & !is.na(x1) & x1  < `x2.5` ~ "x1_first",
TRUE ~ NA_character_
)
) %>%
dplyr::select(participant, base_story, order_group)
# ---------- Keep ONLY rows where the metric truly exists; attach order ----------
df_metric <- df0 %>%
dplyr::left_join(order_map, by = c("participant","base_story")) %>%
dplyr::filter(!is.na(trial_median_rescaled), !is.na(order_group)) %>%
dplyr::mutate(
order_group = factor(order_group, levels = c("x1_first","x2.5_first")),
speech_rate = forcats::fct_drop(speech_rate)
)
# Quick sanity checks (optional)
cat("Rows with metric:", nrow(df_metric), "\n")
print(table(df_metric$speech_rate, useNA="ifany"))
print(table(df_metric$order_group, useNA="ifany"))
if (nrow(df_metric) == 0) stop("No non-missing trial_median_rescaled rows after attaching order.")
# ---------- Model: Speed × Order if both orders present; else Speed-only ----------
has_two_orders <- nlevels(df_metric$order_group) >= 2
has_two_speeds <- nlevels(df_metric$speech_rate) >= 2
if (has_two_orders && has_two_speeds) {
m <- lmer(
trial_median_rescaled ~ speech_rate * order_group +
(1 | digit_span_grp) + (1 | digit_noise_grp),
data = df_metric
)
cat("\n=== LMM — trial_median_rescaled ~ speech_rate * order_group ===\n")
print(summary(m), corr = FALSE)
emm <- emmeans(m, ~ speech_rate * order_group)
cat("\n=== Estimated means (Speech × Order) ===\n"); print(emm)
cmp <- contrast(emm, method = "revpairwise", by = "order_group")  # x2.5 - x1 within each order
cat("\n=== Pairwise (x2.5 - x1) within each Order ===\n"); print(cmp)
} else if (has_two_speeds) {
message("Only one order_group present among metric rows; fitting speech-only model.")
m <- lmer(
trial_median_rescaled ~ speech_rate +
(1 | digit_span_grp) + (1 | digit_noise_grp),
data = df_metric
)
cat("\n=== LMM — trial_median_rescaled ~ speech_rate ===\n")
print(summary(m), corr = FALSE)
emm <- emmeans(m, ~ speech_rate)
cat("\n=== Estimated means by Speech rate ===\n"); print(emm)
print(contrast(emm, method = "revpairwise"))
} else {
stop("speech_rate has <2 levels among rows with the metric.")
}
# EMMs from your fitted model `m`
emm_df <- as.data.frame(emmeans(m, ~ speech_rate * order_group))
# --- p-value for order difference at x2.5 (for the star) ---
ord_within_rate <- as.data.frame(
contrast(emmeans(m, ~ order_group | speech_rate), method = "revpairwise")
)
p_x25 <- ord_within_rate %>%
dplyr::filter(speech_rate == "x2.5") %>%
dplyr::pull(p.value)
star_lab <- ifelse(p_x25 < .001, "***",
ifelse(p_x25 < .01, "**",
ifelse(p_x25 < .05, "*", "ns")))
# y-range spanned by the two order EMMs at x2.5
y_stats <- emm_df %>%
dplyr::filter(speech_rate == "x2.5") %>%
dplyr::summarise(ymin = min(emmean), ymax = max(emmean), .groups = "drop") %>%
dplyr::mutate(y_mid = (ymin + ymax)/2)
# --- Plot ---
# choose two distinct purples
# keep your purples, emm_df, y_stats, star_lab, etc. defined above
bracket_x <- 2.13   # a touch right of "x2.5" (discrete position 2)
tick_dx   <- 0.06   # horizontal tick length
ggplot(emm_df, aes(x = speech_rate, y = emmean,
group = order_group, color = order_group)) +
geom_line(linewidth = 1) +
geom_point(size = 4, shape = 16) +
geom_linerange(aes(ymin = lower.CL, ymax = upper.CL), linewidth = 0.9) +
scale_x_discrete(limits = c("x1","x2.5"),
expand = expansion(mult = c(0.05, 0.25))) +  # right padding for bracket
scale_color_manual(
values = purples,
breaks = c("x1_first","x2.5_first"),
labels = c("x1 first","x2.5 first"),
name   = "Presentation Order"
) +
labs(x = "Speech Rate", y = "Predicted Slider Score") +
# --- single bracket & star at x2.5 (to the right), with clipping off ---
geom_segment(data = y_stats,
aes(x = bracket_x, xend = bracket_x, y = ymin, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymin, yend = ymin),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymax, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_text(data = y_stats,
aes(x = bracket_x + 0.06, y = y_mid, label = star_lab),
inherit.aes = FALSE, size = 5) +
scale_y_continuous(breaks = c(0, 0.5, 1)) +
coord_cartesian(ylim = c(0, 1), clip = "off") +
theme_classic(base_size = 14) +
theme(
legend.position = c(0.98, 0.30),
legend.title = element_text(size = 12),
legend.justification = c(1, 1),
legend.background = element_rect(fill = scales::alpha("white", 0.7), color = NA),
aspect.ratio = 1,
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 12)
) +
guides(color = guide_legend(override.aes = list(linetype = 0, shape = 16, size = 3)))
# ---- PANEL A: MCQ (pinks, WITH legend) ----
p_mcq <- ggplot(emm_mcq, aes(x = speech_rate, y = prob,
group = order_group, color = order_group)) +
geom_line(linewidth = 1) +
geom_point(size = 4, shape = 16) +
geom_linerange(aes(ymin = asymp.LCL, ymax = asymp.UCL), linewidth = 0.9) +
scale_x_discrete(limits = c("x1","x2.5"),
expand = expansion(mult = c(0.05, 0.25))) +
scale_color_manual(
values = c("x1_first"="#C2185B","x2.5_first"="#F48FB1"),
breaks = c("x1_first","x2.5_first"),
labels = c("x1 first","x2.5 first"),
name   = "Presentation Order",
drop   = FALSE               # <- keep legend entries
) +
labs(x = "Speech Rate", y = "Predicted Multiple-Choice Accuracy") +
geom_segment(data = y_stats_mcq,
aes(x = bracket_x, xend = bracket_x, y = ymin, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats_mcq,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymin, yend = ymin),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats_mcq,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymax, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_text(data = y_stats_mcq,
aes(x = bracket_x + 0.06, y = y_mid, label = star_lab_mcq),
inherit.aes = FALSE, size = 5) +
scale_y_continuous(breaks = c(0, 0.5, 1)) +
coord_cartesian(ylim = c(0, 1), clip = "off") +
theme_classic(base_size = 14) +
theme(
legend.position      = c(0.98, 0.30),
legend.justification = c(1, 1),
legend.title         = element_text(size = 12),
legend.background    = element_rect(fill = scales::alpha("white", 0.7), color = NA),
aspect.ratio         = 1,
axis.text.x          = element_text(size = 12),
axis.text.y          = element_text(size = 12),
plot.margin          = margin(5.5, 20, 5.5, 5.5)
) +
guides(color = guide_legend(override.aes = list(linetype = 0, shape = 16, size = 3)))
# ---- PANEL B: RT slider metric (purples, WITH legend) ----
p_rt <- ggplot(emm_df, aes(x = speech_rate, y = emmean,
group = order_group, color = order_group)) +
geom_line(linewidth = 1) +
geom_point(size = 4, shape = 16) +
geom_linerange(aes(ymin = lower.CL, ymax = upper.CL), linewidth = 0.9) +
scale_x_discrete(limits = c("x1","x2.5"),
expand = expansion(mult = c(0.05, 0.25))) +
scale_color_manual(
values = c("x1_first"="#6A3D9A","x2.5_first"="#B26BF2"),
breaks = c("x1_first","x2.5_first"),
labels = c("x1 first","x2.5 first"),
name   = "Presentation Order",
drop   = FALSE
) +
labs(x = "Speech Rate", y = "Predicted Slider Score") +
geom_segment(data = y_stats,
aes(x = bracket_x, xend = bracket_x, y = ymin, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymin, yend = ymin),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_segment(data = y_stats,
aes(x = bracket_x, xend = bracket_x - tick_dx, y = ymax, yend = ymax),
inherit.aes = FALSE, linewidth = 0.6, color = "black") +
geom_text(data = y_stats,
aes(x = bracket_x + 0.06, y = y_mid, label = star_lab),
inherit.aes = FALSE, size = 5) +
scale_y_continuous(breaks = c(0, 0.5, 1)) +
coord_cartesian(ylim = c(0, 1), clip = "off") +
theme_classic(base_size = 14) +
theme(
legend.position      = c(0.98, 0.30),
legend.justification = c(1, 1),
legend.title         = element_text(size = 12),
legend.background    = element_rect(fill = scales::alpha("white", 0.7), color = NA),
aspect.ratio         = 1,
axis.text.x          = element_text(size = 12),
axis.text.y          = element_text(size = 12),
plot.margin          = margin(5.5, 20, 5.5, 5.5)
) +
guides(color = guide_legend(override.aes = list(linetype = 0, shape = 16, size = 3)))
# ---- Combine 1×2; keep text sizes identical across panels ----
(p_mcq | p_rt) +
plot_layout(widths = c(1, 1)) &
theme(text = element_text(size = 14))  # uniform base text size
# ---- Aggregate MCQ to segment-level ----
agg_mcq <- df.data %>%
mutate(
mcq_bin = as.integer(multiple_choice_accuracy %in% c(TRUE, "TRUE", "True", 1)),
speed   = factor(ifelse(speech_rate == 1, "slow", "fast"), levels = c("slow","fast")),
base_story = if ("base_story" %in% names(.)) base_story else sub("_sped$", "", story_name),
digit_span_grp  = factor(digit_span_score),
digit_noise_grp = factor(digit_in_noise_score)
) %>%
filter(!is.na(mcq_bin), !is.na(speed),
!is.na(digit_span_grp), !is.na(digit_noise_grp)) %>%
group_by(participant, base_story, speed, digit_span_grp, digit_noise_grp) %>%
summarise(
n_correct = sum(mcq_bin, na.rm = TRUE),
n_total   = dplyr::n(),        # usually 5; handles any missing items
.groups   = "drop"
) %>%
filter(n_total > 0)
# ---- Binomial GLMM on counts ----
m_speed_agg <- glmer(
cbind(n_correct, n_total - n_correct) ~ speed +
(1 | digit_span_grp) + (1 | digit_noise_grp),
data = agg_mcq, family = binomial
# , control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
cat("\n=== Aggregated model (Binomial n) summary ===\n")
print(summary(m_speed_agg), corr = FALSE)
# ---- Estimated probabilities & fast/slow contrast ----
emm_speed_agg <- emmeans(m_speed_agg, ~ speed, type = "response")
cmp_speed_agg <- contrast(emm_speed_agg, method = "revpairwise")  # fast / slow
cat("\n=== Estimated probabilities by speed (aggregated) ===\n")
print(emm_speed_agg)
cat("\n=== Contrast (fast / slow) — aggregated ===\n")
print(cmp_speed_agg)
df_mcq <- as.data.frame(emm_speed_agg) %>%
transmute(speed,
estimate = prob,
lower    = asymp.LCL,
upper    = asymp.UCL,
outcome  = "MCQ accuracy")
# Slider: continuous scale
df_slider <- as.data.frame(emm_speed_slider) %>%
transmute(speed,
estimate = emmean,
lower    = lower.CL,
upper    = upper.CL,
outcome  = "Slider response")
df_plot <- bind_rows(df_mcq, df_slider)
# --- significance labels (fast vs slow) ---
sig_lab <- function(p) ifelse(p < .001, "***",
ifelse(p < .01,  "**",
ifelse(p < .05,  "*",  "ns")))
p_mcq    <- as.data.frame(contrast(emm_speed,        method = "revpairwise"))$p.value[1]
df_mcq <- as.data.frame(emm_speed_agg) %>%
transmute(speed,
estimate = prob,
lower    = asymp.LCL,
upper    = asymp.UCL,
outcome  = "MCQ accuracy")
# Slider: continuous scale
df_slider <- as.data.frame(emm_speed_slider) %>%
transmute(speed,
estimate = emmean,
lower    = lower.CL,
upper    = upper.CL,
outcome  = "Slider response")
df_plot <- bind_rows(df_mcq, df_slider)
# --- significance labels (fast vs slow) ---
sig_lab <- function(p) ifelse(p < .001, "***",
ifelse(p < .01,  "**",
ifelse(p < .05,  "*",  "ns")))
p_mcq    <- as.data.frame(contrast(emm_speed_agg,        method = "revpairwise"))$p.value[1]
p_slider <- as.data.frame(contrast(emm_speed_slider, method = "revpairwise"))$p.value[1]
lab_mcq     <- sig_lab(p_mcq)
lab_slider  <- sig_lab(p_slider)
# --- bracket geometry (kept close to dots; slider bracket a bit higher) ---
br_gap_mcq    <- 0.028     # above MCQ upper CI
br_gap_slider <- 0.055     # above Slider upper CI (further from dots)
br_tick       <- 0.018     # bracket tick length
star_off      <- 0.010     # stars closer to bracket
br_alpha      <- 0.2     # transparency for black brackets
y_mcq_br    <- pmin(0.97, max(df_mcq$upper,    na.rm = TRUE) + br_gap_mcq)
y_slider_br <- pmin(0.97, max(df_slider$upper, na.rm = TRUE) + br_gap_slider)
# if brackets too close, nudge slider one a touch more
if (abs(y_mcq_br - y_slider_br) < 0.03) y_slider_br <- pmin(0.97, y_mcq_br + 0.05)
# --- colors & legend text ---
cols <- c("MCQ accuracy"    = "#C2185B",  # deep pink
"Slider response" = "#6A3D9A")  # deep purple
legend_labels <- c("MCQ accuracy"    = "Multiple choice question",
"Slider response" = "Slider scores")
# --- PLOT ---
ggplot(df_plot, aes(x = speed, y = estimate, group = outcome, color = outcome)) +
geom_line(linewidth = 1, show.legend = FALSE) +
geom_point(size = 3, shape = 16) +                                        # legend shows dots
geom_linerange(aes(ymin = lower, ymax = upper), linewidth = 0.9, show.legend = FALSE) +
scale_color_manual(values = cols, name = "Comprehension Measure", labels = legend_labels) +
# rename ticks: slow -> x1, fast -> x2.5
scale_x_discrete(labels = c(slow = "x1", fast = "x2.5"),
expand  = expansion(mult = c(0.05, 0.05))) +
scale_y_continuous(breaks = c(0, 0.5, 1), limits = c(0, 1)) +
coord_cartesian(clip = "off") +
labs(x = "Speech Rate", y = "Predicted Comprehension Score") +
# ---- MCQ bracket (semi-transparent black) + star ----
geom_segment(aes(x = 1, xend = 2, y = y_mcq_br, yend = y_mcq_br),
inherit.aes = FALSE, linewidth = 0.6, color = "black", alpha = br_alpha) +
geom_segment(aes(x = 1, xend = 1, y = y_mcq_br, yend = y_mcq_br - br_tick),
inherit.aes = FALSE, linewidth = 0.6, color = "black", alpha = br_alpha) +
geom_segment(aes(x = 2, xend = 2, y = y_mcq_br, yend = y_mcq_br - br_tick),
inherit.aes = FALSE, linewidth = 0.6, color = "black", alpha = br_alpha) +
annotate("text", x = 1.5, y = y_mcq_br + star_off, label = lab_mcq,
color = cols["MCQ accuracy"], size = 5) +
# ---- Slider bracket (higher) + star ----
geom_segment(aes(x = 1, xend = 2, y = y_slider_br, yend = y_slider_br),
inherit.aes = FALSE, linewidth = 0.6, color = "black", alpha = br_alpha) +
geom_segment(aes(x = 1, xend = 1, y = y_slider_br, yend = y_slider_br - br_tick),
inherit.aes = FALSE, linewidth = 0.6, color = "black", alpha = br_alpha) +
geom_segment(aes(x = 2, xend = 2, y = y_slider_br, yend = y_slider_br - br_tick),
inherit.aes = FALSE, linewidth = 0.6, color = "black", alpha = br_alpha) +
annotate("text", x = 1.5, y = y_slider_br + star_off, label = lab_slider,
color = cols["Slider response"], size = 5) +
theme_classic(base_size = 14) +
theme(
aspect.ratio       = 1,
axis.text.x        = element_text(size = 12),
axis.text.y        = element_text(size = 12),
legend.position    = "right", #c(0.98, 0.08),
legend.justification = c(1, 1),
legend.title       = element_text(size = 12),
legend.background  = element_rect(fill = scales::alpha("white", 0.75), color = NA)
) +
guides(color = guide_legend(override.aes = list(linetype = 0, shape = 16, size = 3)))
