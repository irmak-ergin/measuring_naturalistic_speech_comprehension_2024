warning("Slider chunk mismatch for ", part_id)
return()
}
# Split slider into trials by time using breakpoints
make_chunks <- function(slider_df) {
chunks <- list()
last_end <- 0
for (i in seq_along(total_durations)) {
trial_end <- last_end + total_durations[i]
chunk <- slider_df[slider_df$time > last_end & slider_df$time <= trial_end, ]
max_duration <- ifelse(rates[i] == 1, 7.5, 7.55)
chunks[[i]] <- split_slider_into_equal_bins(chunk, max_duration = max_duration)
last_end <- trial_end
}
do.call(rbind, chunks)
}
slider_combined <- make_chunks(bind_rows(s1, s2))
if (nrow(slider_combined) != nrow(df)) {
warning("Mismatch between total trials (", nrow(slider_combined),
") and df rows (", nrow(df), ") for ", part_id)
}
df$slider_values <- slider_combined$slider_values
df$slider_times  <- slider_combined$slider_times
assign(df_name, df, envir = .GlobalEnv)
cat("✓ Updated", df_name, "with 80-bin slider chunks per condition\n")
})
}
split_slider_into_equal_bins <- function(df, duration, n_chunks = 80) {
# Use the known duration per trial to define chunk boundaries
breaks <- seq(0, duration, length.out = n_chunks + 1)
df$chunk_id <- cut(df$time, breaks = breaks, include.lowest = TRUE, labels = FALSE)
split_df <- split(df, df$chunk_id)
result <- vector("list", n_chunks)
for (i in 1:n_chunks) {
chunk <- split_df[[as.character(i)]]
if (!is.null(chunk)) {
result[[i]] <- data.frame(
slider_values = paste0("[", paste(chunk$value, collapse = ", "), "]"),
slider_times  = paste0("[", paste(chunk$time, collapse = ", "), "]"),
stringsAsFactors = FALSE
)
} else {
result[[i]] <- data.frame(
slider_values = "[]",
slider_times  = "[]",
stringsAsFactors = FALSE
)
}
}
do.call(rbind, result)
}
# Main loop
for (part_id in participant_ids) {
local({
df_name <- paste0("df.raw.merged_", part_id)
if (!exists(df_name, envir = .GlobalEnv)) {
warning("Missing merged dataframe for ", part_id)
return()
}
df <- get(df_name, envir = .GlobalEnv)
slider_dir <- file.path(organized_data_path, part_id, paste0("slider_", part_id))
slider_file1 <- list.files(slider_dir, pattern = "part1.*\\.csv$", full.names = TRUE)
slider_file2 <- list.files(slider_dir, pattern = "part2.*\\.csv$", full.names = TRUE)
read_slider <- function(file) {
if (length(file) == 0) return(NULL)
df <- readr::read_csv(file, skip = 1, show_col_types = FALSE)
if (!all(c("value", "time") %in% names(df))) return(NULL)
return(df)
}
s1 <- read_slider(slider_file1)
s2 <- read_slider(slider_file2)
if (is.null(s1) || is.null(s2)) {
warning("Missing or malformed slider files for ", part_id)
return()
}
df_all_chunks <- list()
i <- 1
for (block in 1:2) {
slider_data <- if (block == 1) s1 else s2
n_trials <- 80  # 16 blocks × 5 repetitions
for (j in 1:n_trials) {
trial_df <- slider_data[slider_data$trial == j, ]
if (nrow(trial_df) == 0) next
speech_rate <- df$speech_rate[i]
duration <- if (speech_rate == 1) 7.5 else 7.55
chunked <- split_slider_into_equal_bins(trial_df, duration = duration)
df_all_chunks[[i]] <- chunked
i <- i + 1
}
}
if (length(df_all_chunks) != nrow(df)) {
warning("Slider chunk mismatch for ", part_id)
}
slider_combined <- bind_rows(df_all_chunks[1:nrow(df)])  # truncate just in case
df$slider_values <- slider_combined$slider_values
df$slider_times  <- slider_combined$slider_times
assign(df_name, df, envir = .GlobalEnv)
cat("✓ Updated", df_name, "with slider values using speech-rate specific durations\n")
})
}
View(df.raw.merged_p_1)
# ---------------------------- #
# Parameters
# ---------------------------- #
organized_data_path <- "path_to_your_data"  # Replace with your real path
participant_ids <- c("p_1", "p_2", "p_3", "p_4", "p_5")  # Update with your actual participants
# ---------------------------- #
# Define binning function
# ---------------------------- #
split_slider_into_equal_bins <- function(df, total_duration, n_chunks = 80) {
df <- df %>% filter(!is.na(time))  # clean
breaks <- seq(0, total_duration * 1000, length.out = n_chunks + 1)  # milliseconds
df$chunk_id <- cut(df$time, breaks = breaks, include.lowest = TRUE, labels = FALSE)
split_df <- split(df, df$chunk_id)
result <- vector("list", n_chunks)
for (i in 1:n_chunks) {
chunk <- split_df[[as.character(i)]]
if (!is.null(chunk)) {
result[[i]] <- data.frame(
slider_values = paste0("[", paste(chunk$value, collapse = ", "), "]"),
slider_times  = paste0("[", paste(chunk$time / 1000, collapse = ", "), "]"),
stringsAsFactors = FALSE
)
} else {
result[[i]] <- data.frame(
slider_values = "[]",
slider_times  = "[]",
stringsAsFactors = FALSE
)
}
}
do.call(rbind, result)
}
# ---------------------------- #
# Main loop for each participant
# ---------------------------- #
for (part_id in participant_ids) {
local({
df_name <- paste0("df.raw.merged_", part_id)
if (!exists(df_name, envir = .GlobalEnv)) {
warning("Missing merged dataframe for ", part_id)
return()
}
df <- get(df_name, envir = .GlobalEnv)
slider_dir <- file.path(organized_data_path, part_id, paste0("slider_", part_id))
slider_file1 <- list.files(slider_dir, pattern = "part1.*\\.csv$", full.names = TRUE)
slider_file2 <- list.files(slider_dir, pattern = "part2.*\\.csv$", full.names = TRUE)
read_slider <- function(file) {
if (length(file) == 0) return(NULL)
df <- read_csv(file, skip = 1, show_col_types = FALSE)
if (!all(c("value", "time") %in% names(df))) return(NULL)
return(df)
}
s1 <- read_slider(slider_file1)
s2 <- read_slider(slider_file2)
if (is.null(s1) || is.null(s2)) {
warning("Missing or malformed slider files for ", part_id)
return()
}
# Check each part contains 80 trials
if (nrow(df) != 160) {
warning("Merged df row mismatch: expected 160, got ", nrow(df), " for ", part_id)
}
# Determine trial durations
rate_col <- df$speech_rate
if (length(rate_col) != 160) {
warning("speech_rate column problem for ", part_id)
return()
}
rate_part1 <- rate_col[1:80]
rate_part2 <- rate_col[81:160]
dur_vec1 <- ifelse(rate_part1 == 1, 7.5, 7.55)
dur_vec2 <- ifelse(rate_part2 == 1, 7.5, 7.55)
total_dur1 <- sum(dur_vec1)  # Total seconds
total_dur2 <- sum(dur_vec2)
df1_chunks <- split_slider_into_equal_bins(s1, total_duration = total_dur1, n_chunks = 80)
df2_chunks <- split_slider_into_equal_bins(s2, total_duration = total_dur2, n_chunks = 80)
slider_combined <- bind_rows(df1_chunks, df2_chunks)
if (nrow(slider_combined) != nrow(df)) {
warning("Slider chunk mismatch for ", part_id)
}
df$slider_values <- slider_combined$slider_values
df$slider_times  <- slider_combined$slider_times
assign(df_name, df, envir = .GlobalEnv)
cat("✓ Updated", df_name, "with time-aware slider chunks\n")
})
}
# Set path and participant ids
# Change the folder path to data folder relative to the wd
folder_path <- '/Users/irmakergin/Desktop/experiment_2/pilot/data/raw_data'
# Define the list of participant IDs
participant_ids <- c("p_1","p_2","p_3","p_4","p_5")
# Set path and participant ids
# Change the folder path to data folder relative to the wd
folder_path <- '/Users/irmakergin/Desktop/experiment_2/pilot/data/raw_data'
# Define the list of participant IDs
participant_ids <- c("p_1","p_2","p_3","p_4","p_5")
# Get a list of all files in the folder
files <- dir(folder_path, full.names = TRUE)
# Set a path to save the organized files
organized_data_path <- "/Users/irmakergin/Desktop/experiment_2/pilot/data/organized_data"
# Define binning function
# ---------------------------- #
split_slider_into_equal_bins <- function(df, total_duration, n_chunks = 80) {
df <- df %>% filter(!is.na(time))  # clean
breaks <- seq(0, total_duration * 1000, length.out = n_chunks + 1)  # milliseconds
df$chunk_id <- cut(df$time, breaks = breaks, include.lowest = TRUE, labels = FALSE)
split_df <- split(df, df$chunk_id)
result <- vector("list", n_chunks)
for (i in 1:n_chunks) {
chunk <- split_df[[as.character(i)]]
if (!is.null(chunk)) {
result[[i]] <- data.frame(
slider_values = paste0("[", paste(chunk$value, collapse = ", "), "]"),
slider_times  = paste0("[", paste(chunk$time / 1000, collapse = ", "), "]"),
stringsAsFactors = FALSE
)
} else {
result[[i]] <- data.frame(
slider_values = "[]",
slider_times  = "[]",
stringsAsFactors = FALSE
)
}
}
do.call(rbind, result)
}
# ---------------------------- #
# Main loop for each participant
# ---------------------------- #
for (part_id in participant_ids) {
local({
df_name <- paste0("df.raw.merged_", part_id)
if (!exists(df_name, envir = .GlobalEnv)) {
warning("Missing merged dataframe for ", part_id)
return()
}
df <- get(df_name, envir = .GlobalEnv)
slider_dir <- file.path(organized_data_path, part_id, paste0("slider_", part_id))
slider_file1 <- list.files(slider_dir, pattern = "part1.*\\.csv$", full.names = TRUE)
slider_file2 <- list.files(slider_dir, pattern = "part2.*\\.csv$", full.names = TRUE)
read_slider <- function(file) {
if (length(file) == 0) return(NULL)
df <- read_csv(file, skip = 1, show_col_types = FALSE)
if (!all(c("value", "time") %in% names(df))) return(NULL)
return(df)
}
s1 <- read_slider(slider_file1)
s2 <- read_slider(slider_file2)
if (is.null(s1) || is.null(s2)) {
warning("Missing or malformed slider files for ", part_id)
return()
}
# Check each part contains 80 trials
if (nrow(df) != 160) {
warning("Merged df row mismatch: expected 160, got ", nrow(df), " for ", part_id)
}
# Determine trial durations
rate_col <- df$speech_rate
if (length(rate_col) != 160) {
warning("speech_rate column problem for ", part_id)
return()
}
rate_part1 <- rate_col[1:80]
rate_part2 <- rate_col[81:160]
dur_vec1 <- ifelse(rate_part1 == 1, 7.5, 7.55)
dur_vec2 <- ifelse(rate_part2 == 1, 7.5, 7.55)
total_dur1 <- sum(dur_vec1)  # Total seconds
total_dur2 <- sum(dur_vec2)
df1_chunks <- split_slider_into_equal_bins(s1, total_duration = total_dur1, n_chunks = 80)
df2_chunks <- split_slider_into_equal_bins(s2, total_duration = total_dur2, n_chunks = 80)
slider_combined <- bind_rows(df1_chunks, df2_chunks)
if (nrow(slider_combined) != nrow(df)) {
warning("Slider chunk mismatch for ", part_id)
}
df$slider_values <- slider_combined$slider_values
df$slider_times  <- slider_combined$slider_times
assign(df_name, df, envir = .GlobalEnv)
cat("✓ Updated", df_name, "with time-aware slider chunks\n")
})
}
for (part_id in participant_ids) {
local({
df_name <- paste0("df.raw.merged_", part_id)
if (exists(df_name, envir = .GlobalEnv)) {
df <- get(df_name, envir = .GlobalEnv)
# Step 1: Parse slider_values from string to list of numeric vectors
df$slider_values <- strsplit(as.character(df$slider_values), ",\\s*|\\[|\\]")
df$slider_values <- lapply(df$slider_values, function(x) {
x <- x[nzchar(x)]  # remove empty strings
as.numeric(x)
})
# Step 2: Define rescaling function
rescale_values <- function(values) {
sapply(values, function(x) x / 255)
}
# Step 3: Apply rescaling
df$slider_values_rescaled <- lapply(df$slider_values, rescale_values)
# Save back to environment
assign(df_name, df, envir = .GlobalEnv)
cat("✓ Rescaled slider values for", df_name, "\n")
}
})
}
# Get all participant merged dataframes
participant_dfs <- mget(ls(pattern = "^df\\.raw\\.merged_"))
# Combine all into one dataframe
df.raw <- bind_rows(participant_dfs, .id = "source")
# Extract participant ID from source column and create a proper 'participant' column
df.raw <- df.raw %>%
mutate(participant = gsub("df\\.raw\\.merged_", "", source)) %>%
select(-source)
df.raw <- df.raw %>%
mutate(
slider_times = as.character(slider_times),
duration = map_dbl(slider_times, function(times_str) {
if (is.na(times_str) || times_str == "[]") return(NA_real_)
# Parse string to numeric vector (seconds already)
times <- as.numeric(unlist(strsplit(gsub("\\[|\\]", "", times_str), ",\\s*")))
if (length(times) < 2 || anyNA(times)) return(NA_real_)
duration <- max(times) - min(times)  # duration in seconds
return(duration)
})
)
summary(df.raw$duration)
View(df.raw.merged_p_1)
# Function to split slider stream into exact time chunks based on trial durations
split_slider_by_speech_rate <- function(slider_df, trial_df) {
slider_df <- slider_df %>%
rename(time_ms = time, value = value) %>%
mutate(time = time_ms / 1000)  # convert ms to sec
result <- vector("list", nrow(trial_df))
current_time <- 0
for (i in seq_len(nrow(trial_df))) {
rate <- trial_df$speech_rate[i]
duration <- ifelse(rate == 1, 7.5, 7.55)
# Slice from slider stream based on cumulative time window
trial_slice <- slider_df %>%
filter(time >= current_time & time < current_time + duration)
# Save chunk
result[[i]] <- tibble(
slider_values = paste0("[", paste(trial_slice$value, collapse = ", "), "]"),
slider_times  = paste0("[", paste(trial_slice$time, collapse = ", "), "]")
)
current_time <- current_time + duration
}
bind_rows(result)
}
# Loop over all participants and process their slider data
for (part_id in participant_ids) {
local({
df_name <- paste0("df.raw.merged_", part_id)
if (!exists(df_name, envir = .GlobalEnv)) {
warning("Missing merged dataframe for ", part_id)
return()
}
df <- get(df_name, envir = .GlobalEnv)
slider_dir <- file.path(organized_data_path, part_id, paste0("slider_", part_id))
slider_file1 <- list.files(slider_dir, pattern = "part1.*\\.csv$", full.names = TRUE)
slider_file2 <- list.files(slider_dir, pattern = "part2.*\\.csv$", full.names = TRUE)
read_slider <- function(file) {
if (length(file) == 0) return(NULL)
df <- readr::read_csv(file, skip = 1, show_col_types = FALSE)
if (!all(c("value", "time") %in% names(df))) return(NULL)
return(df)
}
s1 <- read_slider(slider_file1)
s2 <- read_slider(slider_file2)
if (is.null(s1) || is.null(s2)) {
warning("Missing or malformed slider files for ", part_id)
return()
}
# Split df into part1 and part2 trials
df1 <- df[1:80, ]
df2 <- df[81:160, ]
# Assign slider chunks based on cumulative time windows per trial
chunks1 <- split_slider_by_speech_rate(s1, df1)
chunks2 <- split_slider_by_speech_rate(s2, df2)
# Combine chunks
slider_combined <- bind_rows(chunks1, chunks2)
if (nrow(slider_combined) != nrow(df)) {
warning("Slider chunk mismatch for ", part_id)
}
df$slider_values <- slider_combined$slider_values
df$slider_times  <- slider_combined$slider_times
assign(df_name, df, envir = .GlobalEnv)
cat("✓ Updated", df_name, "with time-based slider chunks\n")
})
}
View(df.raw.merged_p_1)
for (part_id in participant_ids) {
local({
df_name <- paste0("df.raw.merged_", part_id)
if (exists(df_name, envir = .GlobalEnv)) {
df <- get(df_name, envir = .GlobalEnv)
# Step 1: Parse slider_values from string to list of numeric vectors
df$slider_values <- strsplit(as.character(df$slider_values), ",\\s*|\\[|\\]")
df$slider_values <- lapply(df$slider_values, function(x) {
x <- x[nzchar(x)]  # remove empty strings
as.numeric(x)
})
# Step 2: Define rescaling function
rescale_values <- function(values) {
sapply(values, function(x) x / 255)
}
# Step 3: Apply rescaling
df$slider_values_rescaled <- lapply(df$slider_values, rescale_values)
# Save back to environment
assign(df_name, df, envir = .GlobalEnv)
cat("✓ Rescaled slider values for", df_name, "\n")
}
})
}
# Get all participant merged dataframes
participant_dfs <- mget(ls(pattern = "^df\\.raw\\.merged_"))
# Combine all into one dataframe
df.raw <- bind_rows(participant_dfs, .id = "source")
# Extract participant ID from source column and create a proper 'participant' column
df.raw <- df.raw %>%
mutate(participant = gsub("df\\.raw\\.merged_", "", source)) %>%
select(-source)
df.raw <- df.raw %>%
mutate(
slider_times = as.character(slider_times),
duration = map_dbl(slider_times, function(times_str) {
if (is.na(times_str) || times_str == "[]") return(NA_real_)
# Parse string to numeric vector (seconds already)
times <- as.numeric(unlist(strsplit(gsub("\\[|\\]", "", times_str), ",\\s*")))
if (length(times) < 2 || anyNA(times)) return(NA_real_)
duration <- max(times) - min(times)  # duration in seconds
return(duration)
})
)
summary(df.raw$duration)
df.raw <- df.raw %>%
mutate(
slider_times = as.character(slider_times),
duration = map_dbl(slider_times, function(times_str) {
if (is.na(times_str) || times_str == "[]") return(NA_real_)
times <- as.numeric(unlist(strsplit(gsub("\\[|\\]", "", times_str), ",\\s*")))
if (length(times) < 2 || anyNA(times)) return(NA_real_)
max(times) - min(times)
})
)
# Print summary
summary(df.raw$duration)
# Identify row with min and max duration
min_row <- df.raw %>% filter(duration == min(duration, na.rm = TRUE))
max_row <- df.raw %>% filter(duration == max(duration, na.rm = TRUE))
# Print detailed info
cat("\n--- Row with MIN duration ---\n")
cat("Duration:", min_row$duration, "\n")
cat("Slider Times:", min_row$slider_times, "\n")
cat("\n--- Row with MAX duration ---\n")
cat("Duration:", max_row$duration, "\n")
cat("Slider Times:", max_row$slider_times, "\n")
# Save merged dataframe to Desktop
# Make a copy first so we don't modify df.raw directly
df.export <- df.raw
# Convert list columns to character strings (if they are lists)
list_cols <- sapply(df.export, is.list)
df.export[list_cols] <- lapply(df.export[list_cols], function(col) {
sapply(col, function(x) paste(x, collapse = ","))
})
# Write to CSV on Desktop
write.csv(df.export, file = "~/Desktop/df.raw.csv", row.names = FALSE)
# Calculate duration
df.raw <- df.raw %>%
mutate(
slider_times = as.character(slider_times),
duration = map_dbl(slider_times, function(times_str) {
if (is.na(times_str) || times_str == "[]") return(NA_real_)
times <- as.numeric(unlist(strsplit(gsub("\\[|\\]", "", times_str), ",\\s*")))
if (length(times) < 2 || anyNA(times)) return(NA_real_)
max(times) - min(times)
})
)
# Summary of durations
summary(df.raw$duration)
# Find full rows with min and max durations
min_row <- df.raw %>% filter(duration == min(duration, na.rm = TRUE))
max_row <- df.raw %>% filter(duration == max(duration, na.rm = TRUE))
# Print full row details
cat("\n--- Row with MIN duration ---\n")
print(min_row)
cat("\n--- Row with MAX duration ---\n")
print(max_row)
# Step 1: Compute durations
df.raw <- df.raw %>%
mutate(
slider_times = as.character(slider_times),
duration = map_dbl(slider_times, function(times_str) {
if (is.na(times_str) || times_str == "[]") return(NA_real_)
times <- as.numeric(unlist(strsplit(gsub("\\[|\\]", "", times_str), ",\\s*")))
if (length(times) < 2 || anyNA(times)) return(NA_real_)
max(times) - min(times)
})
)
# Step 2: Summary
summary(df.raw$duration)
# Step 3: Get rows with min and max durations
min_row <- df.raw %>% filter(duration == min(duration, na.rm = TRUE))
max_row <- df.raw %>% filter(duration == max(duration, na.rm = TRUE))
# Step 4: Print full row info, including slider_times
cat("\n--- Row with MIN duration ---\n")
print(min_row %>% select(everything(), slider_times))
cat("\n--- slider_times for MIN duration row ---\n")
cat(min_row$slider_times, "\n")
cat("\n--- Row with MAX duration ---\n")
print(max_row %>% select(everything(), slider_times))
cat("\n--- slider_times for MAX duration row ---\n")
cat(max_row$slider_times, "\n")
